<!DOCTYPE html>


<html id="bibi">


<head>

    <meta charset="utf-8"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=4.0, user-scalable=yes, shrink-to-fit=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    <title>This E-Book is Published with Bibi | EPUB Reader on your website.</title>

    <!-- # Bibi ... Copyright (c) Satoru MATSUSHIMA - https://bibi.epub.link or https://github.com/satorumurmur/bibi (Licensed under the MIT license.) -->

    <!-- 「わたしのことは『ビビ』と呼んでください。『ビビ』はわたしの名前なんです」 —— エレクトラ・パブリケーヌ『ビビのみぎくるぶし』 -->
    <!-- 「まあ！　それじゃあやっぱり、『ビビ』はわたしの“名前”だったのですね？」 —— ソフィア・パインアイランド『ビビさんたちのこと』 -->
    <!-- 「このあたりにビビさんという人がいると聞いて来たのですが、あなたですか？」 —— ビビ・ララルー『ポケットに眼鏡』 -->

    <link id="bibi-style" rel="stylesheet" href="resources/styles/bibi.css"/>
    <link id="bibi-dress" rel="stylesheet" href="wardrobe/everyday/bibi.dress.css"/>
    <script id="bibi-script" src="resources/scripts/bibi.js"></script>
    <script id="bibi-preset" src="presets/default.js" data-bibi-bookshelf=""></script>

</head>


<body data-bibi-book="">

<div id="bibi-info">
    <h1>This E-Book is Published on the Web with Bibi | EPUB Reader on your website.</h1>
    <ul>
        <li><a href="https://bibi.epub.link">Bibi | EPUB Reader on your website. (Official Website / Japanese)</a></li>
        <li><a href="https://github.com/satorumurmur/bibi">Bibi on GitHub (English)</a></li>
    </ul>
</div>

<div id="bibi-book-data" data-bibi-book-mimetype="application/epub+zip" hidden="hidden">
</div>
<script>

    const waitReady = async () => {
        if (R?.Pages && R?.Pages.length > 0) {
            return true
        }
        let count = 0;
        while (true) {
            if (count > 100) {
                throw new Error('waitReady timeout: ' + (100 * 100) + 'ms')
            }
            if (!R?.Pages || R?.Pages.length === 0) {
                await new Promise(resolve => setTimeout(resolve, 100));
            } else {
                return true;
            }
            count++;
        }
    }
    const getCurrentTexts = async () => {
        await waitReady();
        const iframe = document.querySelector(".current iframe");
        if (!iframe) {
            throw new Error("Can not find iframe");
        }
        // いい感じにchildrenをとるヒューリスティック
        const findChildren = (parentElement) => {
            const rootChildren = parentElement.children;
            return Array.from(rootChildren).flatMap(child => {
                if (child.tagName === "DIV") {
                    return findChildren(child);
                }
                return [child];
            });
        };
        const children = findChildren(iframe.contentWindow.document.body);

        // https://qiita.com/ozoneboy/items/b57bf4e67110b3756390
        function absoluteRect(el) {
            const pos = { top: 0, left: 0 };
            const boundingClientRect = el.getBoundingClientRect();
            pos.top = boundingClientRect.top;
            pos.left = boundingClientRect.left;
            const doc = el.ownerDocument;
            let childWindow = doc.defaultView;
            while (window.top !== childWindow) {
                pos.top += childWindow.frameElement.getBoundingClientRect().top;
                pos.left += childWindow.frameElement.getBoundingClientRect().left;
                childWindow = childWindow.parent;
            }

            return {
                top: pos.top,
                left: pos.left,
                width: boundingClientRect.width,
                height: boundingClientRect.height
            };
        }

        function elementInViewport(el) {
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const { top, left, width, height } = absoluteRect(el);
            const isInViewportPartial = (top >= 0 && top < viewportHeight && left + width > 0 && left + width < viewportHeight)
            return isInViewportPartial;
        }

        const visibleChildren = Array.from(children).filter(el => elementInViewport(el));
        const selectedText = iframe.contentWindow.getSelection().toString();
        return {
            selectedText,
            text: visibleChildren.map(el => el.textContent ?? "").join("\n"),
            lastText: visibleChildren.at(-1)?.textContent ?? "",
        };
    }

    const movePrevPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", -1)
    };
    const moveNextPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", 1)
    };
    const moveToPage = async (pageNumber) => {
        await waitReady();
        // https://github.com/satorumurmur/bibi/issues/78
        R.focusOn({ Destination: { PageIndex: pageNumber - 1 } });
    };
    const getCurrentPage = async () => {
        await waitReady();
        return R.Pages.indexOf(R.Current.List[0].Page) + 1;
    };
    const getTotalPage = async () => {
        await waitReady();
        return R.Pages.length;
    };
    const getBookInfo = async () => {
        await waitReady();
        return {
            type: B.Type, // EPUB
            title: B.Title,
            publisher: B.Publisher,
            author: B.Creator,
            id: B.ID,
        }
    }
    window.addEventListener("DOMContentLoaded", async () => {
        // ?p does not work?
        // https://github.com/satorumurmur/bibi/issues/71
        const url = new URL(location.href);
        const pageNumber = url.searchParams.get("p");
        await waitReady();
        if (pageNumber) {
            await moveToPage(pageNumber);
        }

    })

    const debounce = (fn, ms) => {
        let timer = null;
        return (...args) => {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                fn(...args);
            }, ms);
        };
    }
    /**
     * @param {(currentPage:number) => (() => void)} fn
     */
    const onChangePage = async (fn) => {
        await waitReady();
        const debouncedFn = debounce(fn, 500);
        const onScroll = async () => {
            const currentPage = await getCurrentPage();
            debouncedFn(currentPage);
        };
        E.add("bibi:scrolled", onScroll);
        return () => {
            E.remove("bibi:scrolled", onScroll)
        };
    }
    window.viewerController = {
        movePrevPage,
        moveNextPage,
        moveToPage,
        getTotalPage,
        getCurrentPage,
        getCurrentTexts,
        getBookInfo,
        onChangePage
    };
</script>
</body>


</html>
