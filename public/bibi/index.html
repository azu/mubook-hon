<!DOCTYPE html>


<html id="bibi">


<head>

    <meta charset="utf-8"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=4.0, user-scalable=yes, shrink-to-fit=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    <title>This E-Book is Published with Bibi | EPUB Reader on your website.</title>

    <!-- # Bibi ... Copyright (c) Satoru MATSUSHIMA - https://bibi.epub.link or https://github.com/satorumurmur/bibi (Licensed under the MIT license.) -->

    <!-- 「わたしのことは『ビビ』と呼んでください。『ビビ』はわたしの名前なんです」 —— エレクトラ・パブリケーヌ『ビビのみぎくるぶし』 -->
    <!-- 「まあ！　それじゃあやっぱり、『ビビ』はわたしの“名前”だったのですね？」 —— ソフィア・パインアイランド『ビビさんたちのこと』 -->
    <!-- 「このあたりにビビさんという人がいると聞いて来たのですが、あなたですか？」 —— ビビ・ララルー『ポケットに眼鏡』 -->

    <link id="bibi-style" rel="stylesheet" href="resources/styles/bibi.css"/>
    <link id="bibi-dress" rel="stylesheet" href="wardrobe/everyday/bibi.dress.css"/>
    <script id="bibi-script" src="resources/scripts/bibi.js"></script>
    <script id="bibi-preset" src="presets/default.js" data-bibi-bookshelf=""></script>

</head>


<body data-bibi-book="">

<div id="bibi-info">
    <h1>This E-Book is Published on the Web with Bibi | EPUB Reader on your website.</h1>
    <ul>
        <li><a href="https://bibi.epub.link">Bibi | EPUB Reader on your website. (Official Website / Japanese)</a></li>
        <li><a href="https://github.com/satorumurmur/bibi">Bibi on GitHub (English)</a></li>
    </ul>
</div>

<div id="bibi-book-data" data-bibi-book-mimetype="application/epub+zip" hidden="hidden">
</div>
<script>
    const waitReady = async () => {
        if (R?.Pages && R?.Pages.length > 0) {
            return true
        }
        let count = 0;
        while (true) {
            if (count > 100) {
                throw new Error('waitReady timeout: ' + (100 * 100) + 'ms')
            }
            if (!R?.Pages || R?.Pages.length === 0) {
                await new Promise(resolve => setTimeout(resolve, 100));
            } else {
                return true;
            }
            count++;
        }
    }

    // https://qiita.com/ozoneboy/items/b57bf4e67110b3756390
    function absoluteRect(el) {
        const pos = { top: 0, left: 0 };
        const boundingClientRect = el.getBoundingClientRect();
        pos.top = boundingClientRect.top;
        pos.left = boundingClientRect.left;
        const doc = el.ownerDocument;
        let childWindow = doc.defaultView;
        while (window.top !== childWindow) {
            pos.top += childWindow.frameElement.getBoundingClientRect().top;
            pos.left += childWindow.frameElement.getBoundingClientRect().left;
            childWindow = childWindow.parent;
        }

        return {
            top: pos.top,
            left: pos.left,
            width: boundingClientRect.width,
            height: boundingClientRect.height
        };
    }

    function elementInViewport(el) {
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        const { top, left, width, height } = absoluteRect(el);
        const isInViewportPartial = (top >= 0 && top < viewportHeight && left + width > 0 && left + width < viewportHeight)
        return isInViewportPartial;
    }

    /**
     * 指定された要素と同一階層、同名の要素コレクション内におけるインデックスを取得します。
     *
     * @param {Element} el   要素。
     * @param {String}  name 要素名。
     *
     * @return {Number} インデックス。範囲は 1 〜 N となります。
     */
    function getSiblingElemetsIndex(el, name) {
        var index = 1;
        var sib = el;

        while ((sib = sib.previousElementSibling)) {
            if (sib.nodeName.toLowerCase() === name) {
                ++index;
            }
        }
        return index;
    }

    /**
     * 指定された要素を示すセレクターを取得します。
     *
     * @see http://stackoverflow.com/questions/3620116/get-css-path-from-dom-element
     *
     * @param {Element} el 要素。
     * @param {Window} win
     *
     * @return {Array} セレクター名コレクション。
     */
    function getSelectorFromElement(el, win) {
        const names = [];
        if (!(el instanceof win.Element)) {
            console.log("??")
            return names;
        }
        while (el.nodeType === Node.ELEMENT_NODE) {
            let name = el.nodeName.toLowerCase();
            if (el.id) {
                // id はページ内で一意となるため、これ以上の検索は不要
                name += '#' + el.id;
                names.unshift(name);
                break;
            }

            // 同じ階層に同名要素が複数ある場合は識別のためインデックスを付与する
            // 複数要素の先頭 ( index = 1 ) の場合、インデックスは省略可能
            //
            var index = getSiblingElemetsIndex(el, name);
            if (1 < index) {
                name += ':nth-of-type(' + index + ')';
            }

            names.unshift(name);
            el = el.parentNode;
        }
        return names;
    }

    const findChildren = (parentElement) => {
        const rootChildren = parentElement.children;
        return Array.from(rootChildren).flatMap(child => {
            if (child.tagName === "DIV") {
                return findChildren(child);
            }
            return [child];
        });
    };

    /**
     * @param {Window} contentWindow
     * @returns {*}
     */
    const findFirstVisibleElement = (contentWindow) => {
        const foundElement = findChildren(contentWindow.document.body).find(element => {
            return elementInViewport(element);
        });
        if (!foundElement) {
            console.log("Not Found", { contentWindow })
            return undefined;
        }
        const cssSelector = getSelectorFromElement(foundElement, contentWindow).join(" > ");
        console.log({
            cssSelector
        })
        return {
            element: foundElement,
            cssSelector: cssSelector
        }
    };

    const getCurrentTexts = async () => {
        await waitReady();
        const iframe = document.querySelector(".current iframe");
        if (!iframe) {
            throw new Error("Can not find iframe");
        }
        // いい感じにchildrenをとるヒューリスティック
        const findChildren = (parentElement) => {
            const rootChildren = parentElement.children;
            return Array.from(rootChildren).flatMap(child => {
                if (child.tagName === "DIV") {
                    return findChildren(child);
                }
                return [child];
            });
        };
        const children = findChildren(iframe.contentWindow.document.body);
        const visibleChildren = Array.from(children).filter(el => elementInViewport(el));
        const selectedText = iframe.contentWindow.getSelection().toString();
        return {
            selectedText,
            text: visibleChildren.map(el => el.textContent ?? "").join("\n"),
            lastText: visibleChildren.at(-1)?.textContent ?? "",
        };
    }

    const movePrevPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", -1)
    };
    const moveNextPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", 1)
    };
    /**
     * @param {number} IIPP
     * @returns {Promise<void>}
     */
    const moveToIIPP = async (IIPP) => {
        await waitReady();
        // https://github.com/satorumurmur/bibi/issues/78
        // https://github.com/satorumurmur/bibi/issues/71
        R.focusOn({ Destination: { IIPP: IIPP } });
    };

    // firefox -polyfill
    if (!Element.prototype.scrollIntoViewIfNeeded) {
        Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded = true) {
            const el = this;
            new IntersectionObserver(function ([entry]) {
                const ratio = entry.intersectionRatio;
                if (ratio < 1) {
                    let place = ratio <= 0 && centerIfNeeded ? 'center' : 'nearest';
                    el.scrollIntoView({
                        block: place,
                        inline: place,
                    });
                }
                this.disconnect();
            }).observe(this);
        };
    }

    /**
     * @param {{ ElementSelector:string, ItemIndex:number }} positionMarker
     * @returns {Promise<void>}
     */
    const moveToPositionMarker = async (positionMarker) => {
        await waitReady();
        // select item and query ElementSelector
        console.log("Move to destination", positionMarker);
        // https://github.com/satorumurmur/bibi/issues/78
        // https://github.com/satorumurmur/bibi/issues/71
        // Use DOM API
        try {
            const MoveToItem = R.Items[positionMarker.ItemIndex]
            MoveToItem.contentWindow.document.querySelector(positionMarker.ElementSelector).scrollIntoViewIfNeeded()
            R.focusOn({
                Destination: {
                    ElementSelector: positionMarker.ElementSelector,
                    ItemIndex: positionMarker.ItemIndex
                }
            });
        } catch (error) {
            console.error("Fail to move", error)
        }
    };
    const getCurrentPage = async () => {
        await waitReady();
        return R.Pages.indexOf(R.Current.Pages[0]) + 1;
    };
    /**
     * @returns {Promise<{ItemIndex: number, ElementSelector: string}>}
     */
    const getCurrentPositionMaker = async () => {
        await waitReady();
        const foundElement = findFirstVisibleElement(R.Current.Pages[0].Item.contentWindow);
        const index = R.Current.Pages[0].Item.Index;
        if (!foundElement) {
            return {
                ElementSelector: "body",
                ItemIndex: index
            }
        }
        return {
            ElementSelector: foundElement.cssSelector,
            ItemIndex: index
        };
    };
    /**
     * IIPP is progress point in the book
     * Item Index + Page Progress in the Item
     * https://github.com/satorumurmur/bibi/issues/71
     * @returns {Promise<*>}
     */
    const getCurrentIIPP = async () => {
        await waitReady();
        /**
         * R.Current.Pages[0].Item.Index
         * 39
         * R.Current.Pages[0].IndexInItem
         * 6
         * R.Current.Pages[0].Item.Pages.length
         * 8
         * n.Item.Index + (n.IndexInItem / n.Item.Pages.length)
         * 39 + (6 / 8)
         * = 39.75
         */
        // R.Current.List[0].Page.Index
        return I.PageObserver.getIIPP();
    };
    const getTotalPage = async () => {
        await waitReady();
        return R.Pages.length;
    };
    const getBookInfo = async () => {
        await waitReady();
        return {
            type: B.Type, // EPUB
            title: B.Title,
            publisher: B.Publisher,
            author: B.Creator,
            id: B.ID,
        }
    }

    window.addEventListener("DOMContentLoaded", async () => {
        // ?p does not work?
        // https://github.com/satorumurmur/bibi/issues/71
        const url = new URL(location.href);
        const pageNumber = url.searchParams.get("p");
        await waitReady();
        if (pageNumber) {
            await moveToIIPP(pageNumber);
        }

    })

    const debounce = (fn, ms) => {
        let timer = null;
        return (...args) => {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                fn(...args);
            }, ms);
        };
    }
    /**
     * @param {(currentPage:number) => (() => void)} fn
     */
    const onChangePage = async (fn) => {
        await waitReady();
        const debouncedFn = debounce(fn, 500);
        const onScroll = async () => {
            const currentPage = await getCurrentPage();
            debouncedFn(currentPage);
        };
        E.add("bibi:scrolled", onScroll);
        return () => {
            E.remove("bibi:scrolled", onScroll)
        };
    }

    window.viewerController = {
        movePrevPage,
        moveNextPage,
        moveToIIPP,
        getTotalPage,
        moveToPositionMarker,
        getCurrentPositionMaker,
        getCurrentPage,
        getCurrentIIPP,
        getCurrentTexts,
        getBookInfo,
        onChangePage,
        // utils.
        findFirstVisibleElement
    };
</script>
</body>


</html>
