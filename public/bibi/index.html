<!DOCTYPE html>


<html id="bibi">


<head>

    <meta charset="utf-8"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=4.0, user-scalable=yes, shrink-to-fit=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    <title>This E-Book is Published with Bibi | EPUB Reader on your website.</title>

    <!-- # Bibi ... Copyright (c) Satoru MATSUSHIMA - https://bibi.epub.link or https://github.com/satorumurmur/bibi (Licensed under the MIT license.) -->

    <!-- 「わたしのことは『ビビ』と呼んでください。『ビビ』はわたしの名前なんです」 —— エレクトラ・パブリケーヌ『ビビのみぎくるぶし』 -->
    <!-- 「まあ！　それじゃあやっぱり、『ビビ』はわたしの“名前”だったのですね？」 —— ソフィア・パインアイランド『ビビさんたちのこと』 -->
    <!-- 「このあたりにビビさんという人がいると聞いて来たのですが、あなたですか？」 —— ビビ・ララルー『ポケットに眼鏡』 -->

    <link id="bibi-style" rel="stylesheet" href="resources/styles/bibi.css"/>
    <link id="bibi-dress" rel="stylesheet" href="wardrobe/everyday/bibi.dress.css"/>
    <script id="bibi-script" src="resources/scripts/bibi.js"></script>
    <script id="bibi-preset" src="presets/default.js" data-bibi-bookshelf=""></script>

</head>


<body data-bibi-book="">

<div id="bibi-info">
    <h1>This E-Book is Published on the Web with Bibi | EPUB Reader on your website.</h1>
    <ul>
        <li><a href="https://bibi.epub.link">Bibi | EPUB Reader on your website. (Official Website / Japanese)</a></li>
        <li><a href="https://github.com/satorumurmur/bibi">Bibi on GitHub (English)</a></li>
    </ul>
</div>

<div id="bibi-book-data" data-bibi-book-mimetype="application/epub+zip" hidden="hidden">
</div>
<script>
    const waitReady = async () => {
        if (R?.Pages && R?.Pages.length > 0) {
            return true
        }
        let count = 0;
        while (true) {
            if (count > 100) {
                throw new Error('waitReady timeout: ' + (100 * 100) + 'ms')
            }
            if (!R?.Pages || R?.Pages.length === 0) {
                await new Promise(resolve => setTimeout(resolve, 100));
            } else {
                return true;
            }
            count++;
        }
    }

    // https://qiita.com/ozoneboy/items/b57bf4e67110b3756390
    function absoluteRect(el) {
        const pos = { top: 0, left: 0 };
        const boundingClientRect = el.getBoundingClientRect();
        pos.top = boundingClientRect.top;
        pos.left = boundingClientRect.left;
        const doc = el.ownerDocument;
        let childWindow = doc.defaultView;
        while (window.top !== childWindow) {
            pos.top += childWindow.frameElement.getBoundingClientRect().top;
            pos.left += childWindow.frameElement.getBoundingClientRect().left;
            childWindow = childWindow.parent;
        }

        return {
            top: pos.top,
            left: pos.left,
            width: boundingClientRect.width,
            height: boundingClientRect.height
        };
    }

    function elementInViewport(el) {
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        const { top, left, width, height } = absoluteRect(el);
        const isInViewportPartial = (top >= 0 && top < viewportHeight && left + width > 0 && left + width < viewportHeight)
        return isInViewportPartial;
    }

    /**
     * 指定された要素と同一階層、同名の要素コレクション内におけるインデックスを取得します。
     */
    function getSiblingElemetsIndex(el, name) {
        let index = 1;
        let sib = el;
        while ((sib = sib.previousElementSibling)) {
            if (sib.nodeName.toLowerCase() === name) {
                ++index;
            }
        }
        return index;
    }

    /**
     * Create CSS selector as array。
     * http://stackoverflow.com/questions/3620116/get-css-path-from-dom-element
     */
    function getSelectorFromElement(el, win) {
        const names = [];
        if (!(el instanceof win.Element)) {
            console.log("??")
            return names;
        }
        while (el.nodeType === Node.ELEMENT_NODE) {
            let name = el.nodeName.toLowerCase();

            const index = getSiblingElemetsIndex(el, name);
            if (1 < index) {
                name += ':nth-of-type(' + index + ')';
            }
            names.unshift(name);
            el = el.parentNode;
        }
        return names;
    }

    const findChildren = (parentElement) => {
        const rootChildren = parentElement.children;
        return Array.from(rootChildren).flatMap(child => {
            if (child.tagName === "DIV") {
                return findChildren(child);
            }
            return [child];
        });
    };

    /**
     * @param {Window} contentWindow
     * @returns {*}
     */
    const findFirstVisibleElement = (contentWindow) => {
        const foundElement = findChildren(contentWindow.document.body).find(element => {
            return elementInViewport(element);
        });
        if (!foundElement) {
            console.log("Not Found", { contentWindow })
            return undefined;
        }
        const cssSelector = getSelectorFromElement(foundElement, contentWindow).join(" > ");
        console.log({
            cssSelector
        })
        return {
            element: foundElement,
            cssSelector: cssSelector
        }
    };

    const getCurrentTexts = async () => {
        await waitReady();
        const iframe = document.querySelector(".current iframe");
        if (!iframe) {
            throw new Error("Can not find iframe");
        }
        // いい感じにchildrenをとるヒューリスティック
        const findChildren = (parentElement) => {
            const rootChildren = parentElement.children;
            return Array.from(rootChildren).flatMap(child => {
                if (child.tagName === "DIV") {
                    return findChildren(child);
                }
                return [child];
            });
        };
        const children = findChildren(iframe.contentWindow.document.body);
        const visibleChildren = Array.from(children).filter(el => elementInViewport(el));
        const selectedText = iframe.contentWindow.getSelection().toString();
        return {
            selectedText,
            text: visibleChildren.map(el => el.textContent ?? "").join("\n"),
            lastText: visibleChildren.at(-1)?.textContent ?? "",
        };
    }

    const movePrevPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", -1)
    };
    const moveNextPage = async () => {
        await waitReady();
        E.dispatch("bibi:commands:move-by", 1)
    };
    /**
     * @param {number} IIPP
     * @returns {Promise<void>}
     */
    const moveToIIPP = async (IIPP) => {
        await waitReady();
        // https://github.com/satorumurmur/bibi/issues/78
        // https://github.com/satorumurmur/bibi/issues/71
        R.focusOn({ Destination: { IIPP: IIPP } });
    };

    /**
     * @param {{ ElementSelector:string, ItemIndex:number }} positionMarker
     * @returns {Promise<void>}
     */
    const moveToPositionMarker = async (positionMarker) => {
        await waitReady();
        // select item and query ElementSelector
        console.log("Move to destination", positionMarker);
        // https://github.com/satorumurmur/bibi/issues/78
        // https://github.com/satorumurmur/bibi/issues/71
        // Use DOM API
        try {
            const MoveToItem = R.Items[positionMarker.ItemIndex]
            // firefox -polyfill
            if (!MoveToItem.contentWindow.Element.prototype.scrollIntoViewIfNeeded) {
                MoveToItem.contentWindow.Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded = true) {
                    const el = this;
                    new MoveToItem.contentWindow.IntersectionObserver(function ([entry]) {
                        const ratio = entry.intersectionRatio;
                        if (ratio < 1) {
                            let place = ratio <= 0 && centerIfNeeded ? 'center' : 'nearest';
                            el.scrollIntoView({
                                block: place,
                                inline: place,
                            });
                        }
                        this.disconnect();
                    }).observe(this);
                };
            }
            // FIXME: shake and correct position!!
            MoveToItem.contentWindow.document.body.style.opacity = "0.1";
            MoveToItem.contentWindow.document.querySelector(positionMarker.ElementSelector).scrollIntoViewIfNeeded()
            requestAnimationFrame(async () => {
                await new Promise(resolve => setTimeout(resolve, 100));
                await movePrevPage();
                await new Promise(resolve => setTimeout(resolve, 100))
                await moveNextPage();
                MoveToItem.contentWindow.document.body.style.opacity = "";
            });
            // R.focusOn({
            //     Destination: {
            //         ElementSelector: positionMarker.ElementSelector,
            //         ItemIndex: positionMarker.ItemIndex
            //     }
            // });
        } catch (error) {
            console.error("Fail to move", error)
        }
    };
    const getCurrentPage = async () => {
        await waitReady();
        return R.Pages.indexOf(R.Current.Pages[0]) + 1;
    };
    /**
     * @returns {Promise<{ItemIndex: number, ElementSelector: string}>}
     */
    const getCurrentPositionMaker = async () => {
        await waitReady();
        const foundElement = findFirstVisibleElement(R.Current.Pages[0].Item.contentWindow);
        const index = R.Current.Pages[0].Item.Index;
        if (!foundElement) {
            return {
                ElementSelector: "body",
                ItemIndex: index
            }
        }
        return {
            ElementSelector: foundElement.cssSelector,
            ItemIndex: index
        };
    };
    /**
     * IIPP is progress point in the book
     * Item Index + Page Progress in the Item
     * https://github.com/satorumurmur/bibi/issues/71
     * @returns {Promise<*>}
     */
    const getCurrentIIPP = async () => {
        await waitReady();
        /**
         * R.Current.Pages[0].Item.Index
         * 39
         * R.Current.Pages[0].IndexInItem
         * 6
         * R.Current.Pages[0].Item.Pages.length
         * 8
         * n.Item.Index + (n.IndexInItem / n.Item.Pages.length)
         * 39 + (6 / 8)
         * = 39.75
         */
        // R.Current.List[0].Page.Index
        return I.PageObserver.getIIPP();
    };
    const getTotalPage = async () => {
        await waitReady();
        return R.Pages.length;
    };
    const getBookInfo = async () => {
        await waitReady();
        return {
            type: B.Type, // EPUB
            title: B.Title,
            publisher: B.Publisher,
            author: B.Creator,
            id: B.ID,
        }
    }

    window.addEventListener("DOMContentLoaded", async () => {
        // ?p does not work?
        // https://github.com/satorumurmur/bibi/issues/71
        const url = new URL(location.href);
        const pageNumber = url.searchParams.get("p");
        await waitReady();
        if (pageNumber) {
            await moveToIIPP(pageNumber);
        }

    })

    const debounce = (fn, ms) => {
        let timer = null;
        return (...args) => {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                fn(...args);
            }, ms);
        };
    }
    /**
     * @param {(currentPage:number) => (() => void)} fn
     */
    const onChangePage = async (fn) => {
        await waitReady();
        const debouncedFn = debounce(fn, 500);
        const onScroll = async () => {
            const currentPage = await getCurrentPage();
            debouncedFn(currentPage);
        };
        E.add("bibi:scrolled", onScroll);
        return () => {
            E.remove("bibi:scrolled", onScroll)
        };
    }

    window.viewerController = {
        movePrevPage,
        moveNextPage,
        moveToIIPP,
        getTotalPage,
        moveToPositionMarker,
        getCurrentPositionMaker,
        getCurrentPage,
        getCurrentIIPP,
        getCurrentTexts,
        getBookInfo,
        onChangePage,
        // utils.
        findFirstVisibleElement
    };
</script>
</body>


</html>
